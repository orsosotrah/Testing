name: Dynamic CI

on:
  push:
    branches: ["main"]
  pull_request:
    branches: ["main"]

jobs:
  build:
    runs-on: ubuntu-latest
    env:
      ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
    steps:
      - uses: actions/checkout@v3
      - name: Setup .NET
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: 8.0.x
      
      # Tambahkan langkah diagnosa untuk menemukan solution/project
      - name: Find solution files
        run: |
          echo "Mencari solusi dan project files..."
          find . -name "*.sln" -o -name "*.csproj" | tee project_files.txt
          
      - name: Restore dependencies
        run: |
          # Cek apakah ada file solution
          if ls *.sln 1> /dev/null 2>&1; then
            echo "Solution file ditemukan"
            dotnet restore
          # Cek apakah ada file project
          elif ls *.csproj 1> /dev/null 2>&1; then
            echo "Project file ditemukan di direktori root"
            dotnet restore
          # Cari file solution/project di subdirektori
          elif [ -s project_files.txt ]; then
            echo "Menggunakan file project/solution yang ditemukan"
            PROJECT_FILE=$(head -n 1 project_files.txt)
            echo "Menggunakan file: $PROJECT_FILE"
            dotnet restore "$PROJECT_FILE"
          else
            echo "KESALAHAN: Tidak dapat menemukan project atau solution file"
            find . -type f | grep -v "/\.git/" > all_files.txt
            echo "Semua file dalam repositori:"
            cat all_files.txt
            exit 1
          fi
      - name: Build
        run: |
          # Gunakan variabel PROJECT_FILE jika ada
          if [ -s project_files.txt ]; then
            PROJECT_FILE=$(head -n 1 project_files.txt)
            echo "Membangun project: $PROJECT_FILE"
            # Gunakan level verbose minimal dan redirect semua output ke file
            dotnet build "$PROJECT_FILE" --no-restore -v m > build_full.log 2>&1
            BUILD_EXIT_CODE=$?
            # Jika build gagal, tangkap error dengan lebih fokus
            if [ $BUILD_EXIT_CODE -ne 0 ]; then
              # Potong output yang terlalu panjang, fokus pada error saja
              echo "Build gagal, mencari error..." 
              grep -A 10 -B 3 "error CS" build_full.log > build.log 2>/dev/null || true
              grep -A 5 -B 2 "Build FAILED" build_full.log >> build.log 2>/dev/null || true
              # Tambahkan ringkasan error
              echo -e "\n\n--- RINGKASAN ERROR ---" >> build.log
              grep -E "(error|Error|ERROR) [A-Z0-9]+" build_full.log | head -n 10 >> build.log
              # Tentukan jumlah error
              ERROR_COUNT=$(grep -c -E "(error|Error|ERROR) [A-Z0-9]+" build_full.log)
              echo -e "\nDitemukan total $ERROR_COUNT error dalam build." >> build.log
              cat build.log
              exit 1
            fi
          else
            # Coba build di direktori saat ini
            if ls *.sln 1> /dev/null 2>&1 || ls *.csproj 1> /dev/null 2>&1; then
              echo "Membangun project di direktori saat ini"
              dotnet build --no-restore -v m > build_full.log 2>&1
              BUILD_EXIT_CODE=$?
              # Jika build gagal, tangkap error dengan lebih fokus
              if [ $BUILD_EXIT_CODE -ne 0 ]; then
                # Potong output yang terlalu panjang, fokus pada error saja
                echo "Build gagal, mencari error..."
                grep -A 10 -B 3 "error CS" build_full.log > build.log 2>/dev/null || true
                grep -A 5 -B 2 "Build FAILED" build_full.log >> build.log 2>/dev/null || true
                # Tambahkan ringkasan error
                echo -e "\n\n--- RINGKASAN ERROR ---" >> build.log
                grep -E "(error|Error|ERROR) [A-Z0-9]+" build_full.log | head -n 10 >> build.log
                # Tentukan jumlah error
                ERROR_COUNT=$(grep -c -E "(error|Error|ERROR) [A-Z0-9]+" build_full.log)
                echo -e "\nDitemukan total $ERROR_COUNT error dalam build." >> build.log
                cat build.log
                exit 1
              fi
            else
              echo "KESALAHAN: Tidak dapat menemukan file untuk build" | tee build.log
              exit 1
            fi
          fi
          
      - name: Test
        run: |
          # Gunakan variabel PROJECT_FILE jika ada
          if [ -s project_files.txt ]; then
            PROJECT_FILE=$(head -n 1 project_files.txt)
            echo "Menjalankan test untuk: $PROJECT_FILE"
            dotnet test "$PROJECT_FILE" --no-build --verbosity normal --logger "trx" || true
          else
            # Coba test di direktori saat ini
            if ls *.sln 1> /dev/null 2>&1 || ls *.csproj 1> /dev/null 2>&1; then
              echo "Menjalankan test di direktori saat ini"
              dotnet test --no-build --verbosity normal --logger "trx" || true
            else
              echo "KESALAHAN: Tidak dapat menemukan file untuk test"
            fi
          fi

      - name: Create error log file
        if: failure()
        run: |
          mkdir -p logs
          
          # Buat file error log ringkas khusus untuk API
          echo "## Build Failure Log" > error_api.txt
          echo "Error occurred during the build process." >> error_api.txt
          echo "" >> error_api.txt
          
          # Tambahkan error C# yang paling relevan
          if [ -f build.log ]; then
            # File error log ringkas sudah ada (dibuat oleh step Build)
            grep -E "error CS[0-9]+|Build FAILED|Error\(s\)" build.log >> error_api.txt 2>/dev/null
          elif [ -f build_full.log ]; then
            # Jika hanya ada log lengkap, filter untuk mendapatkan error penting saja
            grep -E "error CS[0-9]+|Build FAILED|Error\(s\)" build_full.log >> error_api.txt 2>/dev/null
          fi
          
          # Cek file C# yang memiliki masalah syntax - HANYA untuk file yang error
          for cs_file in $(find . -name "*.cs"); do
            # Cari error yang terkait dengan file ini
            if [ -f build_full.log ] && grep -q "$cs_file" build_full.log; then
              echo -e "\n## Problematic Code" >> error_api.txt
              echo "File: $cs_file" >> error_api.txt
              head -n 20 "$cs_file" >> error_api.txt
              echo "..." >> error_api.txt
              break  # Hanya tampilkan file pertama yang bermasalah
            fi
          done
          
          # Membuat log lengkap untuk artifact
          echo "## Build Failure Log" > error_log.txt
          echo "Error occurred during the build process." >> error_log.txt
          echo '```' >> error_log.txt
          
          # Tambahkan informasi repository
          echo "## Repository Information" >> error_log.txt
          echo "Working directory: $(pwd)" >> error_log.txt
          echo "Project Structure (hanya .cs, .csproj, .sln files):" >> error_log.txt
          find . -name "*.cs" -o -name "*.csproj" -o -name "*.sln" | sort >> error_log.txt
          
          # Cari dan tambahkan error C# spesifik (syntax errors)
          if [ -f build.log ]; then
            # File error log ringkas sudah ada (dibuat oleh step Build)
            cat build.log >> error_log.txt
          elif [ -f build_full.log ]; then
            # Jika hanya ada log lengkap, filter untuk mendapatkan error penting saja
            echo "## Compilation Errors" >> error_log.txt
            grep -A 5 -B 2 "error CS" build_full.log >> error_log.txt 2>/dev/null || echo "No CS errors found" >> error_log.txt
            echo "## Build Status" >> error_log.txt
            grep -A 3 -B 1 "Build FAILED" build_full.log >> error_log.txt 2>/dev/null || echo "Build status not found" >> error_log.txt
          fi
          
          # Cek file C# yang memiliki masalah syntax
          echo "## C# File Check" >> error_log.txt
          for cs_file in $(find . -name "*.cs"); do
            # Cari error yang terkait dengan file ini
            if [ -f build_full.log ] && grep -q "$cs_file" build_full.log; then
              echo -e "\nPotensi error dalam file: $cs_file" >> error_log.txt
              head -n 20 "$cs_file" >> error_log.txt
              echo "..." >> error_log.txt
            fi
          done
          
          echo '```' >> error_log.txt
          
          # Capture more comprehensive error information
          echo "## Build Log" >> error_log.txt
          cat build.log 2>/dev/null >> error_log.txt || echo "No build.log available"
          
          # Capture test results if available
          echo "## Test Results" >> error_log.txt
          find . -name "*.trx" -exec cat {} \; 2>/dev/null >> error_log.txt || echo "No test results available"
          
          # Include GitHub step summary if available
          echo "## GitHub Step Summary" >> error_log.txt
          cat $GITHUB_STEP_SUMMARY 2>/dev/null >> error_log.txt || echo "No step summary available"
          
          # Include environment information
          echo "## Environment Information" >> error_log.txt
          dotnet --info >> error_log.txt
          
          echo '```' >> error_log.txt

      - name: Analyze failure with Claude
        if: failure() && env.ANTHROPIC_API_KEY != ''
        id: claude_analysis
        continue-on-error: true
        run: |
          ERROR_CONTENT=$(cat error_api.txt)
          
          # Save JSON to file to avoid escaping issues
          cat > request.json << 'EOF'
          {
            "model": "claude-3-haiku-20240307",
            "max_tokens": 1000,
            "system": "Kamu adalah asisten AI DevOps. Analisis log CI/CD dan jelaskan kesalahan dengan jelas. Fokus pada error CS utama dan kesalahan syntax. Jelaskan secara ringkas apa yang salah dan cara memperbaikinya. Jangan sertakan kode boilerplate atau informasi sistem yang tidak relevan dengan error utama.",
            "messages": [
              {
                "role": "user",
                "content": 
          EOF
          
          # Append error content to JSON file - use jq for proper escaping
          echo "$ERROR_CONTENT" | jq -Rs '.' >> request.json
          
          # Close the JSON structure
          cat >> request.json << 'EOF'
              }
            ]
          }
          EOF
          
          # Call Claude API with timeout and verbose output for debugging
          CLAUDE_RESPONSE=$(curl -s -v --max-time 30 -X POST https://api.anthropic.com/v1/messages \
            -H "x-api-key: $ANTHROPIC_API_KEY" \
            -H "anthropic-version: 2023-06-01" \
            -H "content-type: application/json" \
            -d @request.json 2>claude_request.log)
            
          # Save request JSON and response for debugging
          echo "Request sent to Claude:" > claude_debug.log
          cat request.json >> claude_debug.log
          echo -e "\n\nResponse headers:" >> claude_debug.log
          cat claude_request.log >> claude_debug.log
          echo -e "\n\nResponse body:" >> claude_debug.log
          echo "$CLAUDE_RESPONSE" >> claude_debug.log
          
          # Extract response text and capture any errors
          echo "Claude Analysis:"
          if [[ -z "$CLAUDE_RESPONSE" ]]; then
            ERROR_MSG="Analysis not available: (Empty API response - API connection failed)"
            echo "$ERROR_MSG"
            echo "$ERROR_MSG" > claude_analysis.txt
          elif echo "$CLAUDE_RESPONSE" | jq -e '.error' > /dev/null; then
            ERROR_TYPE=$(echo "$CLAUDE_RESPONSE" | jq -r '.error.type // "unknown_error"')
            ERROR_MESSAGE=$(echo "$CLAUDE_RESPONSE" | jq -r '.error.message // "No message"')
            ERROR_MSG="Analysis not available: (API Error: $ERROR_TYPE - $ERROR_MESSAGE)"
            echo "$ERROR_MSG"
            echo "$ERROR_MSG" > claude_analysis.txt
          else
            echo "$CLAUDE_RESPONSE" | jq -r '.content[0].text // "Analysis not available: (Response format error - no content found)"' | tee claude_analysis.txt
          fi
      
      - name: Analyze failure with ChatGPT
        if: failure() && env.OPENAI_API_KEY != '' 
        id: chatgpt_analysis
        continue-on-error: true
        run: |
          ERROR_CONTENT=$(cat error_api.txt)
          
          # Save JSON to file to avoid escaping issues
          cat > request.json << 'EOF'
          {
            "model": "gpt-3.5-turbo",
            "messages": [
              {
                "role": "system",
                "content": "Kamu adalah asisten AI DevOps. Analisis log CI/CD dan jelaskan kesalahan dengan jelas. Fokus pada error CS utama dan kesalahan syntax. Jelaskan secara ringkas apa yang salah dan cara memperbaikinya. Jangan sertakan kode boilerplate atau informasi sistem yang tidak relevan dengan error utama."
              },
              {
                "role": "user",
                "content": 
          EOF
          
          # Append error content to JSON file - use jq for proper escaping
          echo "$ERROR_CONTENT" | jq -Rs '.' >> request.json
          
          # Close the JSON structure
          cat >> request.json << 'EOF'
              }
            ],
            "max_tokens": 1000,
            "temperature": 0
          }
          EOF
          
          # Call OpenAI API with timeout and verbose output for debugging
          CHATGPT_RESPONSE=$(curl -s -v --max-time 30 -X POST https://api.openai.com/v1/chat/completions \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -H "Content-Type: application/json" \
            -d @request.json 2>chatgpt_request.log)
            
          # Save request JSON and response for debugging
          echo "Request sent to ChatGPT:" > chatgpt_debug.log
          cat request.json >> chatgpt_debug.log
          echo -e "\n\nResponse headers:" >> chatgpt_debug.log
          cat chatgpt_request.log >> chatgpt_debug.log
          echo -e "\n\nResponse body:" >> chatgpt_debug.log
          echo "$CHATGPT_RESPONSE" >> chatgpt_debug.log
          
          # Extract response text and capture any errors
          echo "ChatGPT Analysis:"
          if [[ -z "$CHATGPT_RESPONSE" ]]; then
            ERROR_MSG="Analysis not available: (Empty API response - API connection failed)"
            echo "$ERROR_MSG"
            echo "$ERROR_MSG" > chatgpt_analysis.txt
          elif echo "$CHATGPT_RESPONSE" | jq -e '.error' > /dev/null; then
            ERROR_TYPE=$(echo "$CHATGPT_RESPONSE" | jq -r '.error.type // "unknown_error"')
            ERROR_MESSAGE=$(echo "$CHATGPT_RESPONSE" | jq -r '.error.message // "No message"')
            ERROR_MSG="Analysis not available: (API Error: $ERROR_TYPE - $ERROR_MESSAGE)"
            echo "$ERROR_MSG"
            echo "$ERROR_MSG" > chatgpt_analysis.txt
          else
            echo "$CHATGPT_RESPONSE" | jq -r '.choices[0].message.content // "Analysis not available: (Response format error - no content found)"' | tee chatgpt_analysis.txt
          fi
      
      - name: Upload error logs as artifacts
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: error-logs
          path: |
            error_log.txt
            error_api.txt
            claude_analysis.txt
            chatgpt_analysis.txt
            claude_debug.log
            chatgpt_debug.log
            claude_request.log
            chatgpt_request.log
            build.log
            build_full.log
            project_files.txt
            **/*.trx
          if-no-files-found: warn
