# .github/workflows/ci.yml
name: build-and-test
on:
  push:
    branches: ["main"]
  pull_request:
    branches: ["main"]
jobs:
  build:
    runs-on: ubuntu-latest
    env:
      ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
    steps:
      - uses: actions/checkout@v3
      
      # Create logs directory at the beginning of the workflow
      - name: Create logs directory
        run: mkdir -p logs
        
      - name: Setup .NET
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: 8.0.x
      
      # Save error logs if restore fails - improved error detection
      - name: Restore dependencies
        run: |
          dotnet restore > logs/restore_output.log 2>&1
          RESTORE_EXIT=$?
          cat logs/restore_output.log
          if [ $RESTORE_EXIT -ne 0 ]; then
            echo "Restore dependencies failed with exit code $RESTORE_EXIT" | tee -a logs/restore_output.log
            exit 1
          fi
      
      # Save error logs if build fails - improved error detection
      - name: Build
        if: success()
        run: |
          # Use --warnaserror to treat warnings as errors
          dotnet build --no-restore --warnaserror > logs/build_output.log 2>&1
          BUILD_EXIT=$?
          cat logs/build_output.log
          if [ $BUILD_EXIT -ne 0 ]; then
            echo "Build failed with exit code $BUILD_EXIT" | tee -a logs/build_output.log
            exit 1
          fi
      
      # Save error logs if test fails - improved error detection
      - name: Test
        if: success()
        run: |
          dotnet test --no-build --verbosity normal > logs/test_output.log 2>&1
          TEST_EXIT=$?
          cat logs/test_output.log
          if [ $TEST_EXIT -ne 0 ]; then
            echo "Tests failed with exit code $TEST_EXIT" | tee -a logs/test_output.log
            exit 1
          fi
      
      # Manually add a force failure step for testing
      - name: Force failure if TEST_FAILURE is true
        if: ${{ github.event.inputs.TEST_FAILURE == 'true' }}
        run: |
          echo "Forcing build failure for testing purposes"
          exit 1
      
      - name: Analyze failure with Claude
        if: failure()
        run: |
          # Ensure logs directory exists again (in case the job was restarted)
          mkdir -p logs
          
          echo "Running Claude analysis..."
          # Create input file with basic information
          echo "### CI Logs" > logs/claude_input.txt
          echo "Build failed in GitHub Actions" >> logs/claude_input.txt
          
          # Create basic log file if none exist
          if [ ! -f logs/restore_output.log ] && [ ! -f logs/build_output.log ] && [ ! -f logs/test_output.log ]; then
            echo "No detailed log files found. Creating basic error log." | tee logs/error_output.log
            echo "Current directory structure:" >> logs/error_output.log
            find . -type f -name "*.csproj" >> logs/error_output.log
            ls -la >> logs/error_output.log
          fi
          
          # Check for errors in each stage of the pipeline
          echo "--- Build Pipeline Logs ---" >> logs/claude_input.txt
          
          if [ -f logs/restore_output.log ] && [ -s logs/restore_output.log ]; then
            echo "-- Restore Dependencies Log --" >> logs/claude_input.txt
            cat logs/restore_output.log >> logs/claude_input.txt
          fi
          
          if [ -f logs/build_output.log ] && [ -s logs/build_output.log ]; then
            echo "-- Build Log --" >> logs/claude_input.txt
            cat logs/build_output.log >> logs/claude_input.txt
          fi
          
          if [ -f logs/test_output.log ] && [ -s logs/test_output.log ]; then
            echo "-- Test Log --" >> logs/claude_input.txt
            cat logs/test_output.log >> logs/claude_input.txt
          fi
          
          if [ -f logs/error_output.log ] && [ -s logs/error_output.log ]; then
            echo "-- Basic Error Log --" >> logs/claude_input.txt
            cat logs/error_output.log >> logs/claude_input.txt
          fi
          
          # Show the source file with the error
          echo "-- Source Files --" >> logs/claude_input.txt
          find . -name "*.cs" -type f -exec grep -l "XXXX" {} \; | while read file; do
            echo "File with potential error: $file" >> logs/claude_input.txt
            echo "Content:" >> logs/claude_input.txt
            cat "$file" >> logs/claude_input.txt
          done
          
          # Also include GitHub Actions run info
          echo "-- GitHub Actions Context --" >> logs/claude_input.txt
          echo "Workflow: $GITHUB_WORKFLOW" >> logs/claude_input.txt
          echo "Action: $GITHUB_ACTION" >> logs/claude_input.txt
          echo "Event Name: $GITHUB_EVENT_NAME" >> logs/claude_input.txt
          echo "Repository: $GITHUB_REPOSITORY" >> logs/claude_input.txt
          echo "Ref: $GITHUB_REF" >> logs/claude_input.txt
          echo "SHA: $GITHUB_SHA" >> logs/claude_input.txt
          
          # Construct the prompt
          SYSTEM_PROMPT="You are an AI DevOps assistant. You help analyze CI/CD logs from GitHub Actions and explain errors clearly. Suggest what might have gone wrong and how to fix it."
          USER_PROMPT=$(cat logs/claude_input.txt)
          
          # Make API call to Claude
          CLAUDE_RESPONSE=$(curl -s -X POST https://api.anthropic.com/v1/messages \
            -H "x-api-key: $ANTHROPIC_API_KEY" \
            -H "anthropic-version: 2023-06-01" \
            -H "content-type: application/json" \
            -d '{
              "model": "claude-3-haiku-20240307",
              "max_tokens": 1000,
              "system": "'"$SYSTEM_PROMPT"'",
              "messages": [
                {
                  "role": "user",
                  "content": '"$(echo "$USER_PROMPT" | jq -Rs .)"'
                }
              ]
            }')
          
          if [ -z "$CLAUDE_RESPONSE" ]; then
            echo "Error: Empty response from Claude API"
            echo "Failed to get response from Claude API. Check your API key and network connectivity." > logs/claude_analysis.txt
            exit 1
          fi
          
          # Extract the analysis from the response
          ANALYSIS=$(echo $CLAUDE_RESPONSE | jq -r '.content[0].text 2>/dev/null')
          
          if [ -z "$ANALYSIS" ] || [ "$ANALYSIS" = "null" ]; then
            echo "Error: Failed to extract analysis from response"
            echo "Response: $CLAUDE_RESPONSE" | tee logs/claude_response.txt
            echo "Failed to extract analysis from Claude response. See claude_response.txt for raw API response." > logs/claude_analysis.txt
            exit 1
          fi
          
          echo "Claude Analysis:"
          echo "$ANALYSIS"
          echo "$ANALYSIS" > logs/claude_analysis.txt
      
      - name: Upload artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: claude-analysis
          path: logs/
          if-no-files-found: warn
