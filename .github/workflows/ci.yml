name: Dynamic CI

on:
  push:
    branches: ["main"]
  pull_request:
    branches: ["main"]

jobs:
  build:
    runs-on: ubuntu-latest
    env:
      ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
    steps:
      - uses: actions/checkout@v3
      - name: Setup .NET
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: 8.0.x
      
      # Tambahkan langkah diagnosa untuk menemukan solution/project
      - name: Find solution files
        run: |
          echo "Mencari solusi dan project files..."
          find . -name "*.sln" -o -name "*.csproj" | tee project_files.txt
          
      - name: Restore dependencies
        run: |
          # Cek apakah ada file solution
          if ls *.sln 1> /dev/null 2>&1; then
            echo "Solution file ditemukan"
            dotnet restore
          # Cek apakah ada file project
          elif ls *.csproj 1> /dev/null 2>&1; then
            echo "Project file ditemukan di direktori root"
            dotnet restore
          # Cari file solution/project di subdirektori
          elif [ -s project_files.txt ]; then
            echo "Menggunakan file project/solution yang ditemukan"
            PROJECT_FILE=$(head -n 1 project_files.txt)
            echo "Menggunakan file: $PROJECT_FILE"
            dotnet restore "$PROJECT_FILE"
          else
            echo "KESALAHAN: Tidak dapat menemukan project atau solution file"
            find . -type f | grep -v "/\.git/" > all_files.txt
            echo "Semua file dalam repositori:"
            cat all_files.txt
            exit 1
          fi
      - name: Build
        run: |
          # Gunakan variabel PROJECT_FILE jika ada
          if [ -s project_files.txt ]; then
            PROJECT_FILE=$(head -n 1 project_files.txt)
            echo "Membangun project: $PROJECT_FILE"
            dotnet build "$PROJECT_FILE" --no-restore -v d > build.log 2>&1 || (cat build.log && exit 1)
          else
            # Coba build di direktori saat ini
            if ls *.sln 1> /dev/null 2>&1 || ls *.csproj 1> /dev/null 2>&1; then
              echo "Membangun project di direktori saat ini"
              dotnet build --no-restore -v d > build.log 2>&1 || (cat build.log && exit 1)
            else
              echo "KESALAHAN: Tidak dapat menemukan file untuk build" | tee build.log
              exit 1
            fi
          fi
          
      - name: Test
        run: |
          # Gunakan variabel PROJECT_FILE jika ada
          if [ -s project_files.txt ]; then
            PROJECT_FILE=$(head -n 1 project_files.txt)
            echo "Menjalankan test untuk: $PROJECT_FILE"
            dotnet test "$PROJECT_FILE" --no-build --verbosity normal --logger "trx" || true
          else
            # Coba test di direktori saat ini
            if ls *.sln 1> /dev/null 2>&1 || ls *.csproj 1> /dev/null 2>&1; then
              echo "Menjalankan test di direktori saat ini"
              dotnet test --no-build --verbosity normal --logger "trx" || true
            else
              echo "KESALAHAN: Tidak dapat menemukan file untuk test"
            fi
          fi

      - name: Create error log file
        if: failure()
        run: |
          mkdir -p logs
          echo "## Build Failure Log" > error_log.txt
          echo "Error occurred during the build process." >> error_log.txt
          echo '```' >> error_log.txt
          
          # Tambahkan informasi repository
          echo "## Repository Information" >> error_log.txt
          echo "Repository structure:" >> error_log.txt
          find . -type f -not -path "*/\.*" | sort >> error_log.txt
          
          # Tangkap error MSB1003 jika ada
          if grep -q "MSB1003" build.log 2>/dev/null; then
            echo "## MSB1003 Error Detected" >> error_log.txt
            echo "Error: Tidak dapat menemukan project atau solution file." >> error_log.txt
            echo "Working directory: $(pwd)" >> error_log.txt
          fi
          
          # Capture more comprehensive error information
          echo "## Build Log" >> error_log.txt
          cat build.log 2>/dev/null >> error_log.txt || echo "No build.log available"
          
          # Capture test results if available
          echo "## Test Results" >> error_log.txt
          find . -name "*.trx" -exec cat {} \; 2>/dev/null >> error_log.txt || echo "No test results available"
          
          # Include GitHub step summary if available
          echo "## GitHub Step Summary" >> error_log.txt
          cat $GITHUB_STEP_SUMMARY 2>/dev/null >> error_log.txt || echo "No step summary available"
          
          # Include environment information
          echo "## Environment Information" >> error_log.txt
          dotnet --info >> error_log.txt
          
          echo '```' >> error_log.txt

      - name: Analyze failure with Claude
        if: failure() && env.ANTHROPIC_API_KEY != ''
        id: claude_analysis
        continue-on-error: true
        run: |
          ERROR_CONTENT=$(cat error_log.txt)
          
          # Save JSON to file to avoid escaping issues
          cat > request.json << 'EOF'
          {
            "model": "claude-3-haiku-20240307",
            "max_tokens": 1000,
            "system": "Kamu adalah asisten AI DevOps. Analisis log CI/CD dan jelaskan kesalahan dengan jelas. Tampilkan ulang pesan kesalahannya.",
            "messages": [
              {
                "role": "user",
                "content": 
          EOF
          
          # Append error content to JSON file - use jq for proper escaping
          echo "$ERROR_CONTENT" | jq -Rs '.' >> request.json
          
          # Close the JSON structure
          cat >> request.json << 'EOF'
              }
            ]
          }
          EOF
          
          # Call Claude API with timeout and verbose output for debugging
          CLAUDE_RESPONSE=$(curl -s -v --max-time 30 -X POST https://api.anthropic.com/v1/messages \
            -H "x-api-key: $ANTHROPIC_API_KEY" \
            -H "anthropic-version: 2023-06-01" \
            -H "content-type: application/json" \
            -d @request.json 2>claude_request.log)
            
          # Save request JSON and response for debugging
          echo "Request sent to Claude:" > claude_debug.log
          cat request.json >> claude_debug.log
          echo -e "\n\nResponse headers:" >> claude_debug.log
          cat claude_request.log >> claude_debug.log
          echo -e "\n\nResponse body:" >> claude_debug.log
          echo "$CLAUDE_RESPONSE" >> claude_debug.log
          
          # Extract response text and capture any errors
          echo "Claude Analysis:"
          if [[ -z "$CLAUDE_RESPONSE" ]]; then
            ERROR_MSG="Analysis not available: (Empty API response - API connection failed)"
            echo "$ERROR_MSG"
            echo "$ERROR_MSG" > claude_analysis.txt
          elif echo "$CLAUDE_RESPONSE" | jq -e '.error' > /dev/null; then
            ERROR_TYPE=$(echo "$CLAUDE_RESPONSE" | jq -r '.error.type // "unknown_error"')
            ERROR_MESSAGE=$(echo "$CLAUDE_RESPONSE" | jq -r '.error.message // "No message"')
            ERROR_MSG="Analysis not available: (API Error: $ERROR_TYPE - $ERROR_MESSAGE)"
            echo "$ERROR_MSG"
            echo "$ERROR_MSG" > claude_analysis.txt
          else
            echo "$CLAUDE_RESPONSE" | jq -r '.content[0].text // "Analysis not available: (Response format error - no content found)"' | tee claude_analysis.txt
          fi
      
      - name: Analyze failure with ChatGPT
        if: failure() && env.OPENAI_API_KEY != '' 
        id: chatgpt_analysis
        continue-on-error: true
        run: |
          ERROR_CONTENT=$(cat error_log.txt)
          
          # Save JSON to file to avoid escaping issues
          cat > request.json << 'EOF'
          {
            "model": "gpt-3.5-turbo",
            "messages": [
              {
                "role": "system",
                "content": "Kamu adalah asisten AI DevOps. Analisis log CI/CD dan jelaskan kesalahan dengan jelas. Tampilkan ulang pesan kesalahannya."
              },
              {
                "role": "user",
                "content": 
          EOF
          
          # Append error content to JSON file - use jq for proper escaping
          echo "$ERROR_CONTENT" | jq -Rs '.' >> request.json
          
          # Close the JSON structure
          cat >> request.json << 'EOF'
              }
            ],
            "max_tokens": 1000,
            "temperature": 0
          }
          EOF
          
          # Call OpenAI API with timeout and verbose output for debugging
          CHATGPT_RESPONSE=$(curl -s -v --max-time 30 -X POST https://api.openai.com/v1/chat/completions \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -H "Content-Type: application/json" \
            -d @request.json 2>chatgpt_request.log)
            
          # Save request JSON and response for debugging
          echo "Request sent to ChatGPT:" > chatgpt_debug.log
          cat request.json >> chatgpt_debug.log
          echo -e "\n\nResponse headers:" >> chatgpt_debug.log
          cat chatgpt_request.log >> chatgpt_debug.log
          echo -e "\n\nResponse body:" >> chatgpt_debug.log
          echo "$CHATGPT_RESPONSE" >> chatgpt_debug.log
          
          # Extract response text and capture any errors
          echo "ChatGPT Analysis:"
          if [[ -z "$CHATGPT_RESPONSE" ]]; then
            ERROR_MSG="Analysis not available: (Empty API response - API connection failed)"
            echo "$ERROR_MSG"
            echo "$ERROR_MSG" > chatgpt_analysis.txt
          elif echo "$CHATGPT_RESPONSE" | jq -e '.error' > /dev/null; then
            ERROR_TYPE=$(echo "$CHATGPT_RESPONSE" | jq -r '.error.type // "unknown_error"')
            ERROR_MESSAGE=$(echo "$CHATGPT_RESPONSE" | jq -r '.error.message // "No message"')
            ERROR_MSG="Analysis not available: (API Error: $ERROR_TYPE - $ERROR_MESSAGE)"
            echo "$ERROR_MSG"
            echo "$ERROR_MSG" > chatgpt_analysis.txt
          else
            echo "$CHATGPT_RESPONSE" | jq -r '.choices[0].message.content // "Analysis not available: (Response format error - no content found)"' | tee chatgpt_analysis.txt
          fi
      
      - name: Upload error logs as artifacts
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: error-logs
          path: |
            error_log.txt
            claude_analysis.txt
            chatgpt_analysis.txt
            claude_debug.log
            chatgpt_debug.log
            claude_request.log
            chatgpt_request.log
            build.log
            project_files.txt
            **/*.trx
          if-no-files-found: warn
