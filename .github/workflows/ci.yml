# .github/workflows/ci.yml
name: build-and-test
on:
  push:
    branches: ["main"]
  pull_request:
    branches: ["main"]
jobs:
  build:
    runs-on: ubuntu-latest
    env:
      ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
    steps:
      - uses: actions/checkout@v3
      
      # Create logs directory at the beginning of the workflow
      - name: Create logs directory
        run: mkdir -p logs
        
      - name: Setup .NET
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: 8.0.x
      
      # Improved restore dependencies step with debugging
      - name: Restore dependencies
        run: |
          echo "Starting dotnet restore..."
          echo "Current directory: $(pwd)"
          echo "Project files available:"
          find . -name "*.csproj" -o -name "*.sln"
          
          # Run restore with verbose output
          dotnet restore --verbosity detailed > logs/restore_output.log 2>&1
          RESTORE_EXIT=$?
          
          # Display the log content
          echo "Restore log content:"
          cat logs/restore_output.log
          
          # Exit with the same code as restore
          if [ $RESTORE_EXIT -ne 0 ]; then
            echo "Restore dependencies failed with exit code $RESTORE_EXIT"
            exit $RESTORE_EXIT
          fi
      
      # Build step 
      - name: Build
        if: success()
        run: |
          dotnet build --no-restore --warnaserror > logs/build_output.log 2>&1
          BUILD_EXIT=$?
          cat logs/build_output.log
          if [ $BUILD_EXIT -ne 0 ]; then
            echo "Build failed with exit code $BUILD_EXIT"
            exit $BUILD_EXIT
          fi
      
      # Test step
      - name: Test
        if: success()
        run: |
          dotnet test --no-build --verbosity normal > logs/test_output.log 2>&1
          TEST_EXIT=$?
          cat logs/test_output.log
          if [ $TEST_EXIT -ne 0 ]; then
            echo "Tests failed with exit code $TEST_EXIT"
            exit $TEST_EXIT
          fi
      
      # Manual failure step for testing
      - name: Force failure if TEST_FAILURE is true
        if: ${{ github.event.inputs.TEST_FAILURE == 'true' }}
        run: |
          echo "Forcing build failure for testing purposes"
          exit 1
      
      - name: Analyze failure with Claude
        if: failure()
        run: |
          # Ensure logs directory exists again
          mkdir -p logs
          
          echo "Running Claude analysis..."
          # Create input file with basic information
          echo "### CI Logs" > logs/claude_input.txt
          echo "Build failed in GitHub Actions" >> logs/claude_input.txt
          
          # Check for errors in each stage of the pipeline
          echo "--- Build Pipeline Logs ---" >> logs/claude_input.txt
          
          if [ -f logs/restore_output.log ] && [ -s logs/restore_output.log ]; then
            echo "-- Restore Dependencies Log --" >> logs/claude_input.txt
            cat logs/restore_output.log >> logs/claude_input.txt
          fi
          
          if [ -f logs/build_output.log ] && [ -s logs/build_output.log ]; then
            echo "-- Build Log --" >> logs/claude_input.txt
            cat logs/build_output.log >> logs/claude_input.txt
          fi
          
          if [ -f logs/test_output.log ] && [ -s logs/test_output.log ]; then
            echo "-- Test Log --" >> logs/claude_input.txt
            cat logs/test_output.log >> logs/claude_input.txt
          fi
          
          # Show the source file with the error
          echo "-- Source Files --" >> logs/claude_input.txt
          find . -name "*.cs" -type f -exec grep -l "XXXX" {} \; | while read file; do
            echo "File with potential error: $file" >> logs/claude_input.txt
            echo "Content:" >> logs/claude_input.txt
            cat "$file" >> logs/claude_input.txt
          done
          
          # GitHub Actions context
          echo "-- GitHub Actions Context --" >> logs/claude_input.txt
          echo "Workflow: $GITHUB_WORKFLOW" >> logs/claude_input.txt
          echo "Repository: $GITHUB_REPOSITORY" >> logs/claude_input.txt
          echo "Ref: $GITHUB_REF" >> logs/claude_input.txt
          
          # Save input for debugging
          echo "Claude input created, content saved for debugging:"
          cat logs/claude_input.txt
          
          # System prompt
          SYSTEM_PROMPT="You are an AI DevOps assistant. Analyze CI/CD logs and explain errors clearly."
          USER_PROMPT=$(cat logs/claude_input.txt)
          
          # Save prompt to a temporary JSON file instead of inline JSON
          echo '{
            "model": "claude-3-haiku-20240307",
            "max_tokens": 1000,
            "system": "'"$SYSTEM_PROMPT"'",
            "messages": [
              {
                "role": "user",
                "content": '"$(echo "$USER_PROMPT" | jq -Rs)"'
              }
            ]
          }' > logs/claude_request.json
          
          # Debug: display the generated JSON
          echo "Claude API request:"
          cat logs/claude_request.json
          
          # Make API call to Claude using the JSON file
          CLAUDE_RESPONSE=$(curl -s -X POST https://api.anthropic.com/v1/messages \
            -H "x-api-key: $ANTHROPIC_API_KEY" \
            -H "anthropic-version: 2023-06-01" \
            -H "content-type: application/json" \
            -d @logs/claude_request.json)
          
          # Save full response for debugging
          echo "$CLAUDE_RESPONSE" > logs/claude_response.json
          
          if [ -z "$CLAUDE_RESPONSE" ]; then
            echo "Error: Empty response from Claude API"
            exit 1
          fi
          
          # Extract the analysis - fixed jq syntax
          echo "Extracting analysis from Claude response..."
          ANALYSIS=$(echo "$CLAUDE_RESPONSE" | jq -r '.content[0].text')
          
          if [ -z "$ANALYSIS" ] || [ "$ANALYSIS" = "null" ]; then
            echo "Error: Failed to extract analysis from response"
            echo "Response structure:" 
            echo "$CLAUDE_RESPONSE" | jq '.'
            exit 1
          fi
          
          echo "Claude Analysis:"
          echo "$ANALYSIS"
          echo "$ANALYSIS" > logs/claude_analysis.txt
      
      - name: Upload artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: claude-analysis
          path: logs/
          if-no-files-found: warn
